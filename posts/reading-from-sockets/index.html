<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reading from Sockets | tomregan.github.io</title>
<meta name=keywords content><meta name=description content="This is a story about how I learned to read streams from sockets, or to put it another way:
{% highlight diff %}
strncpy(msg_buf, &ldquo;HTTP/1.0 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN); strncpy(msg_buf, &ldquo;HTTP/1.1 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN); {% endhighlight %} How I learned to stop worrying and begin to implement HTTP/1.1.
That&rsquo;s pushy. All it knows is it doesn&rsquo;t know.
HTTP/1.0 For most of the practical work I&rsquo;ve done with sockets until now I&rsquo;ve used datagrams, so I decided that all socket reads, including streaming connections, work in the same way as HTTP/1."><meta name=author content><link rel=canonical href=https://tomregan.github.io/posts/reading-from-sockets/><link crossorigin=anonymous href=/assets/css/stylesheet.2d57c2ec5c1393c947086a457dd198f941b9476b45ce2a2405529f16729999ae.css integrity="sha256-LVfC7FwTk8lHCGpFfdGY+UG5R2tFziokBVKfFnKZma4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomregan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomregan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomregan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tomregan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tomregan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomregan.github.io/posts/reading-from-sockets/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Reading from Sockets"><meta property="og:description" content="This is a story about how I learned to read streams from sockets, or to put it another way:
{% highlight diff %}
strncpy(msg_buf, &ldquo;HTTP/1.0 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN); strncpy(msg_buf, &ldquo;HTTP/1.1 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN); {% endhighlight %} How I learned to stop worrying and begin to implement HTTP/1.1.
That&rsquo;s pushy. All it knows is it doesn&rsquo;t know.
HTTP/1.0 For most of the practical work I&rsquo;ve done with sockets until now I&rsquo;ve used datagrams, so I decided that all socket reads, including streaming connections, work in the same way as HTTP/1."><meta property="og:type" content="article"><meta property="og:url" content="https://tomregan.github.io/posts/reading-from-sockets/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-09-22T00:00:00+00:00"><meta property="article:modified_time" content="2012-09-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reading from Sockets"><meta name=twitter:description content="This is a story about how I learned to read streams from sockets, or to put it another way:
{% highlight diff %}
strncpy(msg_buf, &ldquo;HTTP/1.0 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN); strncpy(msg_buf, &ldquo;HTTP/1.1 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN); {% endhighlight %} How I learned to stop worrying and begin to implement HTTP/1.1.
That&rsquo;s pushy. All it knows is it doesn&rsquo;t know.
HTTP/1.0 For most of the practical work I&rsquo;ve done with sockets until now I&rsquo;ve used datagrams, so I decided that all socket reads, including streaming connections, work in the same way as HTTP/1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomregan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reading from Sockets","item":"https://tomregan.github.io/posts/reading-from-sockets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reading from Sockets","name":"Reading from Sockets","description":"This is a story about how I learned to read streams from sockets, or to put it another way:\n{% highlight diff %}\nstrncpy(msg_buf, \u0026ldquo;HTTP/1.0 404 Not Found\\r\\n\u0026rdquo;, HTTP_RESPONSE_LEN); strncpy(msg_buf, \u0026ldquo;HTTP/1.1 404 Not Found\\r\\n\u0026rdquo;, HTTP_RESPONSE_LEN); {% endhighlight %} How I learned to stop worrying and begin to implement HTTP/1.1.\nThat\u0026rsquo;s pushy. All it knows is it doesn\u0026rsquo;t know.\nHTTP/1.0 For most of the practical work I\u0026rsquo;ve done with sockets until now I\u0026rsquo;ve used datagrams, so I decided that all socket reads, including streaming connections, work in the same way as HTTP/1.","keywords":[],"articleBody":"This is a story about how I learned to read streams from sockets, or to put it another way:\n{% highlight diff %}\nstrncpy(msg_buf, “HTTP/1.0 404 Not Found\\r\\n”, HTTP_RESPONSE_LEN); strncpy(msg_buf, “HTTP/1.1 404 Not Found\\r\\n”, HTTP_RESPONSE_LEN); {% endhighlight %} How I learned to stop worrying and begin to implement HTTP/1.1.\nThat’s pushy. All it knows is it doesn’t know.\nHTTP/1.0 For most of the practical work I’ve done with sockets until now I’ve used datagrams, so I decided that all socket reads, including streaming connections, work in the same way as HTTP/1.0, which is to open a new connection for every request. The code I used to implement my reads was something like this:\n{% highlight c %} int fd, new_fd; char buf [REQUEST_BUFFER_LEN +1]; /* 1023 + 1 */ socklen_t size = sizeof(struct sockaddr_in);\n/* a bunch of socket initialization */\nfor (;;) { new_fd = accept(fd, (struct sockaddr *)\u0026peer_addr, (socklen_t ) \u0026size); / fork / recv(new_fd, buf, REQUEST_HEAD_LEN, 0); / process request and send response */ close(new_fd); } {% endhighlight %}\nIt turns out this is almost entirely wrong.\nHTTP/1.1 When I sent an HTTP/1.1 header I found that the server would regularly block on accept even though the client was waiting on a response.\nclose Calling close on the server is more involved that is immediately apparent, as pushes glasses up nose RFC 2616 clearly states…\nPersistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection. This signaling takes place using the Connection header field section 14.10. Once a close has been signaled, the client MUST NOT send any more requests on that connection.\nit continues in (14.10)…\nHTTP/1.1 defines the “close” connection option for the sender to signal that the connection will be closed after completion of the response. For example, Connection: close\nSo the correct thing to do before closing a connection is to send Connection: close in the header, and not quietly close after each response like I had been doing.\nThe second bug I found was a sound lesson in RTFM. Here are the salient points:\n“[Accpet] creates a new socket…. The original socket remains open.”\nI did a bit of mental arithmatic, and I counted two sockets in total. I went back to the code and reviewed it pretty extensively, and found I was only ever closing the new socket desctiptor returned by accept.\nThe bug was obvious when I checked netstat and found dozens of sockets held in CLOSE_WAIT. This is the result of the client closing the connection, but the server failing to respond.\nThis demonstrates the solution as it’s implemented in pushy, where sockfd is the listening socket, and peerfd is the connected host.\n{% highlight c %} if ((pid = fork()) == 0) { close(sockfd); log_conn(FINE, \u0026peer_addr, “connected\\n”); accept_request(peerfd, \u0026peer_addr); log_conn(FINE, \u0026peer_addr, “done serving request\\n”); exit(0); } log_ln(DEBUG, “forked process %i\\n”, pid); close(peerfd); {% endhighlight %}\nThere are lots of good resources. I’ve been referring to RFC 2616 as I go. The man pages for sockets are easy to read, and nicely augmented by a couple of papers on BSD4.4 IPC,\nAn Introductory 4.4BSD Interprocess Communication Tutorial An Advanced 4.4BSD Interprocess Communication Tutorial ","wordCount":"534","inLanguage":"en","datePublished":"2012-09-22T00:00:00Z","dateModified":"2012-09-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomregan.github.io/posts/reading-from-sockets/"},"publisher":{"@type":"Organization","name":"tomregan.github.io","logo":{"@type":"ImageObject","url":"https://tomregan.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomregan.github.io/ accesskey=h title="tomregan.github.io (Alt + H)">tomregan.github.io</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://tomregan.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://tomregan.github.io/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tomregan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tomregan.github.io/posts/>Posts</a></div><h1 class=post-title>Reading from Sockets</h1><div class=post-meta><span title='2012-09-22 00:00:00 +0000 UTC'>22 September 2012</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;534 words</div></header><div class=post-content><p>This is a story about how I learned to read streams from sockets, or
to put it another way:</p><p>{% highlight diff %}</p><ul><li>strncpy(msg_buf, &ldquo;HTTP/1.0 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN);</li></ul><ul><li>strncpy(msg_buf, &ldquo;HTTP/1.1 404 Not Found\r\n&rdquo;, HTTP_RESPONSE_LEN);
{% endhighlight %}</li></ul><p>How I learned to stop worrying and begin to implement <code>HTTP/1.1</code>.</p><p>That&rsquo;s <a href=https://github.com/TomRegan/pushy>pushy</a>. All it knows is <a href=http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.4>it doesn&rsquo;t know</a>.</p><h2 id=http10>HTTP/1.0<a hidden class=anchor aria-hidden=true href=#http10>#</a></h2><p>For most of the practical work I&rsquo;ve done with sockets until now
I&rsquo;ve used datagrams, so I decided that all socket
reads, including streaming connections, work in the same way as
HTTP/1.0, which is to open a new
connection for every request. The code I used to implement
my reads was something like this:</p><p>{% highlight c %}
int fd, new_fd;
char buf [REQUEST_BUFFER_LEN +1]; /* 1023 + 1 */
socklen_t size = sizeof(struct sockaddr_in);</p><p>/* a bunch of socket initialization */</p><p>for (;;) {
new_fd = accept(fd, (struct sockaddr *)&amp;peer_addr, (socklen_t <em>) &amp;size);
/</em> fork <em>/
recv(new_fd, buf, REQUEST_HEAD_LEN, 0);
/</em> process request and send response */
close(new_fd);
}
{% endhighlight %}</p><p>It turns out this is almost entirely wrong.</p><h2 id=http11>HTTP/1.1<a hidden class=anchor aria-hidden=true href=#http11>#</a></h2><p>When I sent an HTTP/1.1 header I found that the server would regularly
block on <code>accept</code> even though the client was waiting on a response.</p><h3 id=close>close<a hidden class=anchor aria-hidden=true href=#close>#</a></h3><p>Calling <code>close</code> on the server is more involved that is immediately
apparent, as <em>pushes glasses up nose</em> <a href=https://tools.ietf.org/html/rfc2616#section-8.1.2>RFC 2616</a>
clearly states&mldr;</p><blockquote><p>Persistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection. This signaling takes place using the Connection header field section 14.10. Once a close has been signaled, the client MUST NOT send any more requests on that connection.</p></blockquote><p>it continues in (<a href=https://tools.ietf.org/html/rfc2616#section-14.10>14.10</a>)&mldr;</p><blockquote><p>HTTP/1.1 defines the &ldquo;close&rdquo; connection option for the sender to
signal that the connection will be closed after completion of the
response. For example,
Connection: close</p></blockquote><p>So the correct thing to do before closing a connection is to send
<code>Connection: close</code> in the header, and not quietly close after each
response like I had been doing.</p><p>The second bug I found was a sound lesson in RTFM. Here are the
salient points:</p><blockquote><p>&ldquo;[Accpet] creates a new socket&mldr;. The original socket remains open.&rdquo;</p></blockquote><p>I did a bit of mental arithmatic, and I counted two sockets in total.
I went back to the code and reviewed it pretty extensively, and found I was
only ever closing the new socket desctiptor returned by <code>accept</code>.</p><p>The bug was obvious when I checked <code>netstat</code> and found dozens of
sockets held in <code>CLOSE_WAIT</code>. This is the result of the client closing the
connection, but the server failing to respond.</p><p>This demonstrates the solution as it&rsquo;s implemented in pushy, where
<code>sockfd</code> is the listening socket, and <code>peerfd</code> is the connected host.</p><p>{% highlight c %}
if ((pid = fork()) == 0) {
close(sockfd);
log_conn(FINE, &amp;peer_addr, &ldquo;connected\n&rdquo;);
accept_request(peerfd, &amp;peer_addr);
log_conn(FINE, &amp;peer_addr, &ldquo;done serving request\n&rdquo;);
exit(0);
}
log_ln(DEBUG, &ldquo;forked process %i\n&rdquo;, pid);
close(peerfd);
{% endhighlight %}</p><p>There are lots of good resources. I&rsquo;ve been referring to <a href=https://tools.ietf.org/html/rfc2616#section-8.1.2>RFC 2616</a>
as I go. The man pages for sockets are easy to read, and nicely
augmented by a couple of papers on BSD4.4 IPC,</p><ul><li>An Introductory 4.4BSD Interprocess Communication Tutorial</li><li>An Advanced 4.4BSD Interprocess Communication Tutorial</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tomregan.github.io/>tomregan.github.io</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>