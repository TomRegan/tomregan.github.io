<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Comparison method violates its general contract! | tomregan.github.io</title>
<meta name=keywords content="java,comparators,collections"><meta name=description content="ComparatorVerifier is a library for verifying Comparators. Check it out!
Java&rsquo;s standard sorting algorithm, TimSort, is a clever hybrid algorithm that uses a deceptively simple insight into the typical pattern of elements in arrays. Unfortunately the insight is couched deep in mathematical obscurity:
Entropy considerations provide a natural estimate of the number of comparisons to sort incompletely shuffled data. From an information theoretic viewpoint, the number of comparisons needed to sort a permutation is an upper bound on the Kolmogorov complexity of the permutation."><meta name=author content><link rel=canonical href=https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/><link crossorigin=anonymous href=/assets/css/stylesheet.2d57c2ec5c1393c947086a457dd198f941b9476b45ce2a2405529f16729999ae.css integrity="sha256-LVfC7FwTk8lHCGpFfdGY+UG5R2tFziokBVKfFnKZma4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomregan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomregan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomregan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tomregan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tomregan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Comparison method violates its general contract!"><meta property="og:description" content="ComparatorVerifier is a library for verifying Comparators. Check it out!
Java&rsquo;s standard sorting algorithm, TimSort, is a clever hybrid algorithm that uses a deceptively simple insight into the typical pattern of elements in arrays. Unfortunately the insight is couched deep in mathematical obscurity:
Entropy considerations provide a natural estimate of the number of comparisons to sort incompletely shuffled data. From an information theoretic viewpoint, the number of comparisons needed to sort a permutation is an upper bound on the Kolmogorov complexity of the permutation."><meta property="og:type" content="article"><meta property="og:url" content="https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/"><meta property="og:image" content="https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-04T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-04T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/cover.jpg"><meta name=twitter:title content="Comparison method violates its general contract!"><meta name=twitter:description content="ComparatorVerifier is a library for verifying Comparators. Check it out!
Java&rsquo;s standard sorting algorithm, TimSort, is a clever hybrid algorithm that uses a deceptively simple insight into the typical pattern of elements in arrays. Unfortunately the insight is couched deep in mathematical obscurity:
Entropy considerations provide a natural estimate of the number of comparisons to sort incompletely shuffled data. From an information theoretic viewpoint, the number of comparisons needed to sort a permutation is an upper bound on the Kolmogorov complexity of the permutation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomregan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Comparison method violates its general contract!","item":"https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Comparison method violates its general contract!","name":"Comparison method violates its general contract!","description":"ComparatorVerifier is a library for verifying Comparators. Check it out!\nJava\u0026rsquo;s standard sorting algorithm, TimSort, is a clever hybrid algorithm that uses a deceptively simple insight into the typical pattern of elements in arrays. Unfortunately the insight is couched deep in mathematical obscurity:\nEntropy considerations provide a natural estimate of the number of comparisons to sort incompletely shuffled data. From an information theoretic viewpoint, the number of comparisons needed to sort a permutation is an upper bound on the Kolmogorov complexity of the permutation.","keywords":["java","comparators","collections"],"articleBody":"ComparatorVerifier is a library for verifying Comparators. Check it out!\nJava’s standard sorting algorithm, TimSort, is a clever hybrid algorithm that uses a deceptively simple insight into the typical pattern of elements in arrays. Unfortunately the insight is couched deep in mathematical obscurity:\nEntropy considerations provide a natural estimate of the number of comparisons to sort incompletely shuffled data. From an information theoretic viewpoint, the number of comparisons needed to sort a permutation is an upper bound on the Kolmogorov complexity of the permutation. A sorting algorithm generates a string of comparisons unique to each permutation. These strings form a prefix-free encoding for permutations. Since there are N 1 permutations, most permutations will require at least 1gN! comparisons. The challenge is to determine classes of permutations which require fewer, and to construct sorting algorithms whose comparison counts approach the information theoretic limit within these classes.\nExcerpt from “Optimistic Sorting and Information Theoretic Complexity” by Peter McIlroy.\nWow. Let’s spend some time breaking this down, and we’ll see if we can come to a better understanding of the tricks TimSort uses, and why it has to throw an exception when things go wrong:\njava.lang.IllegalArgumentException: Comparison method violates its general contract! at java.util.ComparableTimSort.mergeHi(ComparableTimSort.java:835) at java.util.ComparableTimSort.mergeAt(ComparableTimSort.java:453) at java.util.ComparableTimSort.mergeForceCollapse(ComparableTimSort.java:392) at java.util.ComparableTimSort.sort(ComparableTimSort.java:191) at java.util.ComparableTimSort.sort(ComparableTimSort.java:146) at java.util.Arrays.sort(Arrays.java:472) at java.util.Collections.sort(Collections.java:155) ... First Steps With TimSort When I have to reason about sorting, I usually think about a bookshelf, so let’s use that idea to get an insight into what TimSort is doing.\nWhat does TimSort do? It examines a chaotic collection of books and identifies sequences where the books are already arranged alphabetically. How? It scans through the shelf left to right and “filters out” already-ordered groups (called runs). Then it merges these groups, ensuring the books remain in order. Why? It’s much easier to merge small, sorted groups than to re-sort the entire collection from scratch. This approach saves time and effort, What if something goes wrong? Imagine if some books had contradictory labels: to the left of the shelf TimSort decides that Book A should come before Book B, while to the right it thinks that Book A comes after Book B. When you try to merge these groups, the inconsistency becomes impossible to resolve. In TimSort, when it detects such conflicting orders during merging, it stops the process and throws the error: “Comparison method violates its general contract!” This ordering mix-up is a very strange situation for TimSort get itself into! Key to this is the fact that TimSort uses outside help to work out what the ordering of elements in an array should be. It uses a Comparator. In our example of the bookshelf, the comparator would be responsible for knowing the alphabet, and when it’s handed two books, giving the correct answer about which book goes on the shelf first, and which is second.\nBefore we examine TimSort, let’s throw in one last idea to help understand how the comparator might be thinking about the alphabet. You and I probably think of the alphabet running left to right, starting at A and ending at Z. But we should imagine a comparator doesn’t see the alphabet that way! Imagine the alphabet mixed up and arranged around a clock face.\nOur new jumbled up alphabet runs from N to M, and it goes N, O, P, Q, T, U, X, L, H, C, Z, G, D, C, B, A, M, and back to N. Let’s think about that letter N in the 12 o’clock position. Starting from 12 o’clock, N comes after M and before O; O comes after N and after M; but what about M? As the minute hand goes around the clock from 12 it reaches N, and later on M: N comes before M. But after passing M it reaches N. So N comes after M. Clearly N can’t come both after and before M: there’s something wrong with our model of the alphabet, and this is similar to the way a comparator can fail to impose total ordering over its elements. In fact the property it’s breaking here is called transitivity.\nTransitivity In a comparator, transitivity is the property that states, for three elements, 1, 2, and 3, if 1 is smaller than 2, and 2 is smaller than 3, then 1 must be smaller than 3.\nFormally:\nIf x ≤ y and y ≤ z, then x ≤ z Returning to the clock face, we can see how a cycle might be introduced by an incorrectly written comparator, and how it’s possible to get into a loop, like 1 → 2 → 3 → 1.\nTimSort Step by Step Now that we’ve got to grips with this metaphorically, we’ll take a look at an example which is a little closer to the facts. We’ll skip over a lot of technical detail unless it’s helpful to understanding why the exception is thrown. To begin, let’s trace through the sorting of a short list of numbers.\nStep 0: Initial Array Let’s take a simple array that’s partially ordered, which is ideal for TimSort:\n[2, 3, 5, 7, 6, 4, 1, 8, 9] You can visually spot a few runs in there:\n[2, 3, 5, 7, 6, 4, 1, 8, 9] [2, 3, 5, 7] // ascending [6, 4, 1] // descending [8, 9] // ascending Step 1: Detect Runs TimSort will scan the array and identify these sequences. If a run is descending, it reverses it to make it ascending.\n[6, 4, 1] → [1, 4, 6] So after detecting and adjusting runs, we get:\n[2, 3, 5, 7] // already ascending [1, 4, 6] // reversed from [6, 4, 1] [8, 9] // already ascending At this point, TimSort has a stack of runs like:\nruns ← [ [2, 3, 5, 7], [1, 4, 6], [8, 9] ] TimSort will continue to add runs to the run stack until a merge is triggered.\nStep 2: Merge The Runs Now we start merging the runs. First we merge [2, 3, 5, 7] with [1, 4, 6]. To merge them, we compare each run element by element, putting them into a temporary array:\ncompare(2, 1) → 1 wins → [1] compare(2, 4) → 2 wins → [1, 2] compare(3, 4) → 3 wins → [1, 2, 3] compare(5, 4) → 4 wins → [1, 2, 3, 4] compare(5, 6) → 5 wins → [1, 2, 3, 4, 5] compare(7, 6) → 6 wins → [1, 2, 3, 4, 5, 6] 7 left → [1, 2, 3, 4, 5, 6, 7] The newly created run is pushed back onto the stack, and the remaining run stack looks like this:\nruns ← [ [1, 2, 3, 4, 5, 6, 7], [8, 9] ] Step 3: Final Merge Merge [1, 2, 3, 4, 5, 6, 7] with [8, 9].\nThe first list is entirely smaller than the second, so the result is just the full sorted array:\n[1, 2, 3, 4, 5, 6, 7, 8, 9] Triggering a Merge At the end of step one, we said that runs would be stacked up until a merge is triggered. So what triggers a merge? This is key, because the same condition which triggers a merge, is also responsible for detecting that the sort is failing because the comparator is incorrect.\nThe condition is made up of two rules. If either of these rules is broken, a merge is triggered:\nFor three consecutive runs on the stack the length of the top-most run is greater than the combined length of the next two runs The run at the very top of the stack is longer than the next run beneath it When either 1 or 2 is untrue, TimSort stops searching and begins merging the run stack. If these rules are still broken at the end of merging, TimSort sees that the comparator didn’t do its job, and that’s when the exception is thrown.\nGalloping (aka binary search): The Final Puzzle Piece We have to understand galloping because it’s during galloping mode that TimSort detects intransitivity in the Comparator.\nGalloping allows us to “jump ahead” in a run. Let’s look at this in the top two runs from our stack:\nrunA ← [2, 3, 5, 7] runB ← [1, 4, 6] First we do compare(2, 1) and put 1 in our temporary array. We continue:\ncompare(2, 1) second run wins → [1] compare(2, 4) first run wins → [1, 2] compare(3, 4) first run wins → [1, 2, 3] Because our first run is contributing more elements to the temporary array, we’re going to designate it the “winning run,” and change our strategy. Instead of looking at every element, we’re going to perform a binary search by jumping ahead a few elements into a region of uncertainty.\nWe’re guessing the winning run is already so well-ordered that it’ll be several comparisons before we find the next element which is smaller than the element in the second run.\nComparison method violates its general contract We’ve examined how TimSort is supposed to work. Now we’ll look at how it fails. Let’s continue with our example of galloping to see how TimSort detects inconsistencies in Comparators. We’ll go back to our first successful merge, except this time we’re going to imagine we’ve been using an incorrect comparator all along. This comparator has strange ideas about the number 4, and returns different results depending on the number 4 is being compared with. Luckily it’s worked correctly until now, but that’s about to change.\nAfter the first merge, our run stack looked like this:\nruns ← [ [1, 2, 3, 4, 5, 6, 7], [8, 9] ] Let’s imagine we’re galloping through the first run:\n↓ runA ← [1, 2, 3, 4, 5, 6, 7] ↓ runB ← [8, 9] Our first comparison is between 4 and 8. Our comparator incorrectly says that 8 is less than 4 because it has been written improperly. Our next comparison is with 3. Now the comparator returns the correct result, that 8 is greater than 3. We’ve already determined, using the same comparator, that 3 is less than 4, because we’ve previously sorted this run, so our comparator is telling us both that 4 is less than 8 and greater than 3, and that 3 is less than 8 and 4 is greater than 3. We can compare this with our formal definition of transitivity from earlier on:\nIf x ≤ y and y ≤ z, then x ≤ z If 3 ≤ 4 and 4 ≤ 8, then 3 ≤ 8 But our comparator has decided:\n3 \u003c 4 and 3 \u003c 8, but 4 \u003e 8 This could leave TimSort to search endlessly up and down the run, like the minute hand circling a clock, if it didn’t stop to throw the exception.\nWriting Better Comparators Avoid writing your own comparators unnecessarily. Familiarize yourself with the Comparator API in Java, prefer those comparators when they’re available.\nIf you’re writing your own comparator, make sure you understand the comparator contract, which is given in the Comparator Javadoc. A few smells I’ve noticed over the years are stateful comparators, modulo arithmetic, and the use of random values, but human creativity is limitless and a full survey of potential faults is impossible.\nIf you want to use a formal verification framework to test your comparators, you can try out a library I created, ComparatorVerifier. It’s easy to use, and it can detect violations of the comparator contract at test time, rather than mid-way through sorting!\nFurther Reading Comparison Method Violates Its General Contract! (Part 1) by Stuart Marks Comparison Method Violates Its General Contract! (Part 2) by Stuart Marks AI Used in this Post I used ChatGPT to proofread and fact check this post. The chat is at: https://chatgpt.com/share/67f158a2-56ac-8000-b86f-3ca6d50e8c28. I used ChatGPT to generate the image of a clock with letters around it. ","wordCount":"1978","inLanguage":"en","image":"https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/cover.jpg","datePublished":"2025-04-04T00:00:00Z","dateModified":"2025-04-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/"},"publisher":{"@type":"Organization","name":"tomregan.github.io","logo":{"@type":"ImageObject","url":"https://tomregan.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomregan.github.io/ accesskey=h title="tomregan.github.io (Alt + H)">tomregan.github.io</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://tomregan.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://tomregan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tomregan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tomregan.github.io/posts/>Posts</a></div><h1 class=post-title>Comparison method violates its general contract!</h1><div class=post-meta><span title='2025-04-04 00:00:00 +0000 UTC'>4 April 2025</span>&nbsp;·&nbsp;1978 words</div></header><figure class=entry-cover><img loading=lazy src=https://tomregan.github.io/posts/2025-04-04-comparison-method-violates-its-general-contract/cover.jpg alt></figure><div class=post-content><p><strong><a href=https://github.com/TomRegan/comparatorverifier>ComparatorVerifier</a> is a library for verifying Comparators. Check it out!</strong></p><p>Java&rsquo;s standard sorting algorithm, TimSort, is a clever hybrid algorithm
that uses a deceptively simple insight into the typical pattern of elements in
arrays. Unfortunately the insight is couched deep in mathematical
obscurity:</p><blockquote><p>Entropy considerations provide a natural estimate of the number of
comparisons to sort incompletely shuffled data. From an information
theoretic viewpoint, the number of comparisons needed to sort a
permutation is an upper bound on the Kolmogorov complexity of the
permutation. A sorting algorithm generates a string of comparisons
unique to each permutation. These strings form a prefix-free encoding
for permutations. Since there are N 1 permutations, most permutations
will require at least 1gN! comparisons. The challenge is to determine
classes of permutations which require fewer, and to construct sorting
algorithms whose comparison counts approach the information theoretic
limit within these classes.</p></blockquote><p><em>Excerpt from &ldquo;<a href=https://dl.acm.org/doi/pdf/10.5555/313559.313859>Optimistic Sorting and Information Theoretic
Complexity</a>&rdquo; by Peter
McIlroy.</em></p><p>Wow. Let&rsquo;s spend some time breaking this down, and we&rsquo;ll see if we can
come to a better understanding of the tricks TimSort uses, and why it
has to throw an exception when things go wrong:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>java.lang.IllegalArgumentException: Comparison method violates its general contract!
</span></span><span style=display:flex><span>    at java.util.ComparableTimSort.mergeHi(ComparableTimSort.java:835)
</span></span><span style=display:flex><span>    at java.util.ComparableTimSort.mergeAt(ComparableTimSort.java:453)
</span></span><span style=display:flex><span>    at java.util.ComparableTimSort.mergeForceCollapse(ComparableTimSort.java:392)
</span></span><span style=display:flex><span>    at java.util.ComparableTimSort.sort(ComparableTimSort.java:191)
</span></span><span style=display:flex><span>    at java.util.ComparableTimSort.sort(ComparableTimSort.java:146)
</span></span><span style=display:flex><span>    at java.util.Arrays.sort(Arrays.java:472)
</span></span><span style=display:flex><span>    at java.util.Collections.sort(Collections.java:155)
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><h2 id=first-steps-with-timsort>First Steps With TimSort<a hidden class=anchor aria-hidden=true href=#first-steps-with-timsort>#</a></h2><p>When I have to reason about sorting, I usually think about a bookshelf,
so let&rsquo;s use that idea to get an insight into what TimSort is doing.</p><ul><li><strong>What does TimSort do?</strong> It examines a chaotic collection of books
and identifies sequences where the books are already arranged
alphabetically.</li><li><strong>How?</strong> It scans through the shelf left to right and &ldquo;filters out&rdquo;
already-ordered groups (called runs). Then it merges these groups,
ensuring the books remain in order.</li><li><strong>Why?</strong> It&rsquo;s much easier to merge small, sorted groups than to
re-sort the entire collection from scratch. This approach saves time
and effort,</li><li><strong>What if something goes wrong?</strong> Imagine if some books had
contradictory labels: to the left of the shelf TimSort decides that
Book A should come before Book B, while to the right it thinks that
Book A comes after Book B. When you try to merge these groups, the
inconsistency becomes impossible to resolve. In TimSort, when it
detects such conflicting orders during merging, it stops the process
and throws the error: &ldquo;Comparison method violates its general
contract!&rdquo;</li></ul><p>This ordering mix-up is a very strange situation for TimSort get itself
into! Key to this is the fact that TimSort uses outside help to work out
what the ordering of elements in an array should be. It uses a
Comparator. In our example of the bookshelf, the comparator would be
responsible for knowing the alphabet, and when it&rsquo;s handed two books,
giving the correct answer about which book goes on the shelf first, and
which is second.</p><p>Before we examine TimSort, let&rsquo;s throw in one last idea to help
understand how the comparator might be thinking about the alphabet. You
and I probably think of the alphabet running left to right, starting at
A and <em>ending</em> at Z. But we should imagine a comparator doesn&rsquo;t see the
alphabet that way! Imagine the alphabet mixed up and arranged around a
clock face.</p><p><img loading=lazy src=alphabetical-clock-face.png alt="An image of the alphabet out of order and arranged around a clock
face"></p><p>Our new jumbled up alphabet runs from N to M, and it goes N, O, P, Q, T,
U, X, L, H, C, Z, G, D, C, B, A, M, <em>and back to N</em>. Let&rsquo;s think about
that letter N in the 12 o&rsquo;clock position. Starting from 12 o&rsquo;clock, N
comes after M and before O; O comes after N and after M; but what about
M? As the minute hand goes around the clock from 12 it reaches N, and
later on M: N comes before M. But after passing M it reaches N. So N
comes after M. Clearly N can&rsquo;t come both after <em>and</em> before M: there&rsquo;s
something wrong with our model of the alphabet, and this is similar to
the way a comparator can fail to impose <em>total ordering</em> over its
elements. In fact the property it&rsquo;s breaking here is called
transitivity.</p><h3 id=transitivity>Transitivity<a hidden class=anchor aria-hidden=true href=#transitivity>#</a></h3><p>In a comparator, transitivity is the property that states, for three
elements, 1, 2, and 3, if 1 is smaller than 2, and 2 is smaller than 3,
then 1 must be smaller than 3.</p><p>Formally:</p><pre><code>If x ≤ y and y ≤ z, then x ≤ z
</code></pre><p>Returning to the clock face, we can see how a cycle might be introduced
by an incorrectly written comparator, and how it&rsquo;s possible to get into a
loop, like 1 → 2 → 3 → 1.</p><h2 id=timsort-step-by-step>TimSort Step by Step<a hidden class=anchor aria-hidden=true href=#timsort-step-by-step>#</a></h2><p>Now that we&rsquo;ve got to grips with this metaphorically, we&rsquo;ll take a look
at an example which is a little closer to the facts. We&rsquo;ll skip over a
lot of technical detail unless it&rsquo;s helpful to understanding why the
exception is thrown. To begin, let&rsquo;s trace through the sorting of a
short list of numbers.</p><h3 id=step-0-initial-array>Step 0: Initial Array<a hidden class=anchor aria-hidden=true href=#step-0-initial-array>#</a></h3><p>Let&rsquo;s take a simple array that&rsquo;s partially ordered, which is ideal for
TimSort:</p><pre><code>[2, 3, 5, 7, 6, 4, 1, 8, 9]
</code></pre><p>You can visually spot a few runs in there:</p><pre><code>[2, 3, 5, 7, 6, 4, 1, 8, 9]
[2, 3, 5, 7]                   // ascending
            [6, 4, 1]          // descending 
                     [8, 9]    // ascending
</code></pre><h3 id=step-1-detect-runs>Step 1: Detect Runs<a hidden class=anchor aria-hidden=true href=#step-1-detect-runs>#</a></h3><p>TimSort will scan the array and identify these sequences. If a run is
descending, it reverses it to make it ascending.</p><pre><code>[6, 4, 1] → [1, 4, 6]
</code></pre><p>So after detecting and adjusting runs, we get:</p><pre><code>[2, 3, 5, 7]    // already ascending
[1, 4, 6]       // reversed from [6, 4, 1]
[8, 9]          // already ascending
</code></pre><p>At this point, TimSort has a stack of runs like:</p><pre><code>runs ← [
  [2, 3, 5, 7],
  [1, 4, 6],
  [8, 9]
]
</code></pre><p>TimSort will continue to add runs to the run stack until a merge is
triggered.</p><h3 id=step-2-merge-the-runs>Step 2: Merge The Runs<a hidden class=anchor aria-hidden=true href=#step-2-merge-the-runs>#</a></h3><p>Now we start merging the runs. First we merge <code>[2, 3, 5, 7]</code> with
<code>[1, 4, 6]</code>. To merge them, we compare each run element by element,
putting them into a temporary array:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>compare(2, 1) → 1 wins → [1]
</span></span><span style=display:flex><span>compare(2, 4) → 2 wins → [1, 2]
</span></span><span style=display:flex><span>compare(3, 4) → 3 wins → [1, 2, 3]
</span></span><span style=display:flex><span>compare(5, 4) → 4 wins → [1, 2, 3, 4]
</span></span><span style=display:flex><span>compare(5, 6) → 5 wins → [1, 2, 3, 4, 5]
</span></span><span style=display:flex><span>compare(7, 6) → 6 wins → [1, 2, 3, 4, 5, 6]
</span></span><span style=display:flex><span>                7 left → [1, 2, 3, 4, 5, 6, 7]
</span></span></code></pre></div><p>The newly created run is pushed back onto the stack, and the remaining
run stack looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>runs ← [</span>
</span></span><span style=display:flex><span>  [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>],
</span></span><span style=display:flex><span>  [<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>]
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><h3 id=step-3-final-merge>Step 3: Final Merge<a hidden class=anchor aria-hidden=true href=#step-3-final-merge>#</a></h3><p>Merge <code>[1, 2, 3, 4, 5, 6, 7]</code> with <code>[8, 9]</code>.</p><p>The first list is entirely smaller than the second, so the result is
just the full sorted array:</p><pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><h2 id=triggering-a-merge>Triggering a Merge<a hidden class=anchor aria-hidden=true href=#triggering-a-merge>#</a></h2><p>At the end of step one, we said that runs would be stacked up until a
merge is triggered. So what triggers a merge? This is key, because the
same condition which triggers a merge, is also responsible for detecting
that the sort is failing because the comparator is incorrect.</p><p>The condition is made up of two rules. If either of these rules is
broken, a merge is triggered:</p><ol><li>For three consecutive runs on the stack the length of the top-most
run is greater than the combined length of the next two runs</li><li>The run at the very top of the stack is longer than the next run
beneath it</li></ol><p>When either 1 or 2 is untrue, TimSort stops searching and begins merging
the run stack. If these rules are still broken at the end of
merging, TimSort sees that the comparator didn&rsquo;t do its job, and
that&rsquo;s when the exception is thrown.</p><h2 id=galloping-aka-binary-search-the-final-puzzle-piece>Galloping (aka binary search): The Final Puzzle Piece<a hidden class=anchor aria-hidden=true href=#galloping-aka-binary-search-the-final-puzzle-piece>#</a></h2><p>We have to understand galloping because it&rsquo;s during galloping mode that
TimSort detects intransitivity in the Comparator.</p><p>Galloping allows us to &ldquo;jump ahead&rdquo; in a run. Let&rsquo;s look at this in the
top two runs from our stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>runA ← [2, 3, 5, 7]</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>runB ← [1, 4, 6]</span>
</span></span></code></pre></div><p>First we do <code>compare(2, 1)</code> and put 1 in our temporary array. We
continue:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>compare(2, 1) second run wins → [1]
</span></span><span style=display:flex><span>compare(2, 4) first run wins  → [1, 2]
</span></span><span style=display:flex><span>compare(3, 4) first run wins  → [1, 2, 3]
</span></span></code></pre></div><p>Because our first run is contributing more elements to the temporary
array, we&rsquo;re going to designate it the &ldquo;winning run,&rdquo; and change our
strategy. Instead of looking at every element, we&rsquo;re going to perform a
binary search by jumping ahead a few elements into a region of
uncertainty.</p><p>We&rsquo;re guessing the winning run is already so well-ordered that it&rsquo;ll be several
comparisons before we find the next element which is smaller than the
element in the second run.</p><h2 id=comparison-method-violates-its-general-contract>Comparison method violates its general contract<a hidden class=anchor aria-hidden=true href=#comparison-method-violates-its-general-contract>#</a></h2><p>We&rsquo;ve examined how TimSort is supposed to work. Now we&rsquo;ll look at how it
fails. Let&rsquo;s continue with our example of galloping to see how TimSort
detects inconsistencies in Comparators. We&rsquo;ll go back to our first
successful merge, except this time we&rsquo;re going to imagine we&rsquo;ve been
using an incorrect comparator all along. This comparator has strange
ideas about the number 4, and returns different results depending on the
number 4 is being compared with. Luckily it&rsquo;s worked correctly until
now, but that&rsquo;s about to change.</p><p>After the first merge, our run stack looked like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>runs ← [</span>
</span></span><span style=display:flex><span>  [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>],
</span></span><span style=display:flex><span>  [<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>]
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Let&rsquo;s imagine we&rsquo;re galloping through the first run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>                 <span style=color:#ae81ff>↓</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>runA ← [1, 2, 3, 4, 5, 6, 7]</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>↓</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>runB ← [8, 9]</span>
</span></span></code></pre></div><p>Our first comparison is between 4 and 8. Our comparator incorrectly says
that 8 is <em>less than</em> 4 because it has been written improperly. Our next
comparison is with 3. Now the comparator returns the correct result, that
8 is greater than 3. We&rsquo;ve already determined, using the same
comparator, that 3 is less than 4, because we&rsquo;ve previously sorted this
run, so our comparator is telling us both that 4 is less than 8 and
greater than 3, and that 3 is less than 8 and 4 is greater than 3. We
can compare this with our formal definition of transitivity from earlier
on:</p><pre><code>If x ≤ y and y ≤ z, then x ≤ z
If 3 ≤ 4 and 4 ≤ 8, then 3 ≤ 8
</code></pre><p>But our comparator has decided:</p><pre><code>3 &lt; 4 and 3 &lt; 8, but 4 &gt; 8
</code></pre><p>This could leave TimSort to search endlessly up and down the run, like
the minute hand circling a clock, if it didn&rsquo;t stop to throw the
exception.</p><h2 id=writing-better-comparators>Writing Better Comparators<a hidden class=anchor aria-hidden=true href=#writing-better-comparators>#</a></h2><p>Avoid writing your own comparators unnecessarily. Familiarize yourself with the <code>Comparator</code>
API in Java, prefer those comparators when they&rsquo;re available.</p><p>If you&rsquo;re writing your own comparator, make sure you understand the
comparator contract, which is given in the <a href=https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html>Comparator
Javadoc</a>.
A few smells I&rsquo;ve noticed over the years are stateful comparators,
modulo arithmetic, and the use of random values, but human creativity is
limitless and a full survey of potential faults is impossible.</p><p>If you want to use a formal verification framework to test your
comparators, you can try out a library I created,
<a href=https://github.com/TomRegan/comparatorverifier>ComparatorVerifier</a>.
It&rsquo;s easy to use, and it can detect violations of the comparator
contract at test time, rather than mid-way through sorting!</p><h2 id=further-reading>Further Reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2><ul><li><a href="https://www.youtube.com/watch?v=Enwbh6wpnYs">Comparison Method Violates Its General Contract! (Part 1) by Stuart Marks</a></li><li><a href="https://www.youtube.com/watch?v=bvnmbRo7a1Y">Comparison Method Violates Its General Contract! (Part 2) by Stuart Marks</a></li></ul><h2 id=ai-used-in-this-post>AI Used in this Post<a hidden class=anchor aria-hidden=true href=#ai-used-in-this-post>#</a></h2><ul><li>I used ChatGPT to proofread and fact check this post. The
chat is at: <a href=https://chatgpt.com/share/67f158a2-56ac-8000-b86f-3ca6d50e8c28>https://chatgpt.com/share/67f158a2-56ac-8000-b86f-3ca6d50e8c28</a>.</li><li>I used ChatGPT to generate the image of a clock with letters around it.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tomregan.github.io/tags/java/>Java</a></li><li><a href=https://tomregan.github.io/tags/comparators/>Comparators</a></li><li><a href=https://tomregan.github.io/tags/collections/>Collections</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tomregan.github.io/>tomregan.github.io</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>