<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Modular Projects with Bash | tomregan.github.io</title>
<meta name=keywords content><meta name=description content="I try to use bash scripts wherever I can over ruby or python. Partly that&rsquo;s down to stubbornness, but it&rsquo;s mostly because the problems I&rsquo;m trying to solve can be tackled with the tools already available in UNIX.
One of my past sprawling bash projects was a tool that I used for simple, repetitive tasks, like creating new source files from templates, creating working tree structures for projects, running unit tests, and so on."><meta name=author content><link rel=canonical href=https://tomregan.github.io/posts/modular-projects-with-bash/><link crossorigin=anonymous href=/assets/css/stylesheet.2d57c2ec5c1393c947086a457dd198f941b9476b45ce2a2405529f16729999ae.css integrity="sha256-LVfC7FwTk8lHCGpFfdGY+UG5R2tFziokBVKfFnKZma4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tomregan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tomregan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tomregan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tomregan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tomregan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tomregan.github.io/posts/modular-projects-with-bash/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Modular Projects with Bash"><meta property="og:description" content="I try to use bash scripts wherever I can over ruby or python. Partly that&rsquo;s down to stubbornness, but it&rsquo;s mostly because the problems I&rsquo;m trying to solve can be tackled with the tools already available in UNIX.
One of my past sprawling bash projects was a tool that I used for simple, repetitive tasks, like creating new source files from templates, creating working tree structures for projects, running unit tests, and so on."><meta property="og:type" content="article"><meta property="og:url" content="https://tomregan.github.io/posts/modular-projects-with-bash/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-07-19T00:00:00+00:00"><meta property="article:modified_time" content="2012-07-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Modular Projects with Bash"><meta name=twitter:description content="I try to use bash scripts wherever I can over ruby or python. Partly that&rsquo;s down to stubbornness, but it&rsquo;s mostly because the problems I&rsquo;m trying to solve can be tackled with the tools already available in UNIX.
One of my past sprawling bash projects was a tool that I used for simple, repetitive tasks, like creating new source files from templates, creating working tree structures for projects, running unit tests, and so on."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tomregan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Modular Projects with Bash","item":"https://tomregan.github.io/posts/modular-projects-with-bash/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Modular Projects with Bash","name":"Modular Projects with Bash","description":"I try to use bash scripts wherever I can over ruby or python. Partly that\u0026rsquo;s down to stubbornness, but it\u0026rsquo;s mostly because the problems I\u0026rsquo;m trying to solve can be tackled with the tools already available in UNIX.\nOne of my past sprawling bash projects was a tool that I used for simple, repetitive tasks, like creating new source files from templates, creating working tree structures for projects, running unit tests, and so on.","keywords":[],"articleBody":"I try to use bash scripts wherever I can over ruby or python. Partly that’s down to stubbornness, but it’s mostly because the problems I’m trying to solve can be tackled with the tools already available in UNIX.\nOne of my past sprawling bash projects was a tool that I used for simple, repetitive tasks, like creating new source files from templates, creating working tree structures for projects, running unit tests, and so on.\nBy the time I’d got to university it had stopped working. When I tackled the code it was a mess: far beyond human comprehension. The codebase was a nest of sources and global functions, buried spaghetti sed. I had to let it go, and since then I’ve avoided bash for projects I thought might get large.\nBut recently I missed my old project tool kit and decided to create a new one. I know bash is absolutely the right choice for each of the individual tasks. The problem is how to tie them all together.\nWhen I thought about it I figured out I was only missing two important features: the ability to group code into modules or packages, and the ability to contain functions in a namespace. So after an evening’s work I came up with this, which provides a very simple set of functions for managing individual scripts as modules.\n{% highlight bash %} #! /bin/bash\nif [ -z “$INSTALL_LOCATION” ];then msBaseDirectory=\"./\" else [ -d “$INSTALL_LOCATION” ] \u0026\u0026 msBaseDirectory=$INSTALL_LOCATION [ -z “${msBaseDirectory}” ] \u0026\u0026 echo “ERROR: cannot determine the location of modules” fi\nuse to source a module require() {\nlocal sModule=$msBaseDirectory${1//.//} if [ -d $sModule ]; then source $sModule/_init elif [ -f $sModule ]; then source $sModule else echo \"ERROR: could not load module '$sModule'\" exit fi }\nuse to declare a module module() {\nlocal sModule=$1 # transform the module name to a path gsWorkingDir=${sModule//.//} }\nuse to declare an object object() {\nlocal sObject=$1 # create a constructor for the object eval \"${sObject}.new() { __new ${sObject} ${gsWorkingDir}; };\" }\n__new() {\nlocal sObject=$1 local sWorkingDir=$2 for it in ${msBaseDirectory}/${sWorkingDir}/*; do # create functions from the module's contents local sFunction=$(basename $it) eval \"${sObject}.${sFunction}() { source $it; };\" done } {% endhighlight %}\nThe idea is this: a directory becomes a bash module by virtue of having a file called _init. The init file should declare a module and an object, for example:\n{% highlight bash %} #! /bin/bash module foo.bar.baz\nobject Baz {% endhighlight %}\nThe object serves as a namespace for each of the scripts in the module, so it’s possible to call Baz.func, and whatever code is present in the file foo/bar/baz/func will be executed as if it were a function.\nI can make use of these functions by require-ing a module, calling new on its object (which avoids sourcing files unnecessarily), and making method calls on it, as follows:\n{% highlight bash %} #! /bin/bash require foo.bar.baz\nBaz.new Baz.func {% endhighlight %}\nThis executes the script in foo/bar/baz/func, it accepts arguments as would a regular function, and variables scoped with local behave as you would expect.\nSo far this has been a really neat solution for organizing a large bash project, but I won’t be surprised to find limitations in the future.\nSome example source is available here.\n","wordCount":"549","inLanguage":"en","datePublished":"2012-07-19T00:00:00Z","dateModified":"2012-07-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomregan.github.io/posts/modular-projects-with-bash/"},"publisher":{"@type":"Organization","name":"tomregan.github.io","logo":{"@type":"ImageObject","url":"https://tomregan.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tomregan.github.io/ accesskey=h title="tomregan.github.io (Alt + H)">tomregan.github.io</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://tomregan.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://tomregan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tomregan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tomregan.github.io/posts/>Posts</a></div><h1 class=post-title>Modular Projects with Bash</h1><div class=post-meta><span title='2012-07-19 00:00:00 +0000 UTC'>19 July 2012</span>&nbsp;·&nbsp;549 words</div></header><div class=post-content><p>I try to use bash scripts wherever I can over ruby or python. Partly
that&rsquo;s down to stubbornness, but it&rsquo;s mostly because the problems I&rsquo;m
trying to solve can be tackled with the tools already available
in UNIX.</p><p>One of my past sprawling bash projects was a tool that
I used for simple, repetitive tasks, like creating new source files
from templates, creating working tree structures for projects,
running unit tests, and so on.</p><p>By the time I&rsquo;d got to university it had stopped working. When I tackled
the code it was a mess: far beyond human comprehension. The
codebase was a nest of <code>source</code>s and global functions, buried spaghetti
sed. I had to let it go, and since then I&rsquo;ve avoided bash for projects
I thought might get large.</p><p>But recently I missed my old project tool kit and decided to create a
new one. I know bash is absolutely the right choice for each of the
individual tasks. The problem is how to tie them all together.</p><p>When I thought about it I figured out I was only missing two important
features: the ability to group code into modules or packages, and the
ability to contain functions in a namespace. So after an evening&rsquo;s work I
came up with this, which provides a very simple set of functions for
managing individual scripts as modules.</p><p>{% highlight bash %}
#! /bin/bash</p><p>if [ -z &ldquo;$INSTALL_LOCATION&rdquo; ];then
msBaseDirectory="./"
else
[ -d &ldquo;$INSTALL_LOCATION&rdquo; ] && msBaseDirectory=$INSTALL_LOCATION
[ -z &ldquo;${msBaseDirectory}&rdquo; ] && echo &ldquo;ERROR: cannot determine the location of modules&rdquo;
fi</p><h1 id=use-to-source-a-module>use to source a module<a hidden class=anchor aria-hidden=true href=#use-to-source-a-module>#</a></h1><p>require() {</p><pre><code>local sModule=$msBaseDirectory${1//.//}
if [ -d $sModule ]; then
    source $sModule/_init
elif [ -f $sModule ]; then
    source $sModule
else
    echo &quot;ERROR: could not load module '$sModule'&quot;
    exit
fi
</code></pre><p>}</p><h1 id=use-to-declare-a-module>use to declare a module<a hidden class=anchor aria-hidden=true href=#use-to-declare-a-module>#</a></h1><p>module() {</p><pre><code>local sModule=$1

# transform the module name to a path
gsWorkingDir=${sModule//.//}
</code></pre><p>}</p><h1 id=use-to-declare-an-object>use to declare an object<a hidden class=anchor aria-hidden=true href=#use-to-declare-an-object>#</a></h1><p>object() {</p><pre><code>local sObject=$1

# create a constructor for the object
eval &quot;${sObject}.new() { __new ${sObject} ${gsWorkingDir}; };&quot;
</code></pre><p>}</p><p>__new() {</p><pre><code>local sObject=$1
local sWorkingDir=$2

for it in ${msBaseDirectory}/${sWorkingDir}/*; do

    # create functions from the module's contents
    local sFunction=$(basename $it)
    eval &quot;${sObject}.${sFunction}() { source $it; };&quot;
done
</code></pre><p>}
{% endhighlight %}</p><p>The idea is this: a directory becomes a bash module by
virtue of having a file called <code>_init</code>. The init file should declare a
module and an object, for example:</p><p>{% highlight bash %}
#! /bin/bash
module foo.bar.baz</p><p>object Baz
{% endhighlight %}</p><p>The object serves as a namespace for each of the scripts in the module,
so it&rsquo;s possible to call <code>Baz.func</code>, and whatever code is present
in the file <code>foo/bar/baz/func</code> will be executed as if it were a function.</p><p>I can make use of these functions by <code>require</code>-ing a module, calling
<code>new</code> on its object (which avoids sourcing files unnecessarily), and
making method calls on it, as follows:</p><p>{% highlight bash %}
#! /bin/bash
require foo.bar.baz</p><p>Baz.new
Baz.func
{% endhighlight %}</p><p>This executes the script in foo/bar/baz/func, it accepts arguments as
would a regular function, and variables scoped with <code>local</code> behave as you
would expect.</p><p>So far this has been a really neat solution for organizing a large
bash project, but I won&rsquo;t be surprised to find limitations in the future.</p><p>Some example source is available <a href=downloads/code/example.tgz>here</a>.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tomregan.github.io/>tomregan.github.io</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>